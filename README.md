## 责任链模式

### 定义
> 为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用
  而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。
  
### 角色
1. `抽象处理者（Handler）角色`：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。
2. `具体处理者（Concrete Handler）角色`：实现抽象处理者的处理方法，判断能否处理本次请求，
   如果可以处理请求则处理，否则将该请求转给它的后继者。
   
### 优点
1. 职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者
   和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。

2. 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。

3. 在给对象分派职责时，职责链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变
   处理一个请求的职责。

4. 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是
   符合“开闭原则”的。
   
### 缺点
1. 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个
   请求也可能因职责链没有被正确配置而得不到处理。

2. 对于比较长的职责链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。

3. 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。

### 适用场景
1. 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心
   请求的处理对象是谁以及它是如何处理的。

2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。

3. 可动态指定一组对象处理请求，客户端可以动态创建职责链来处理请求，还可以改变链中处理者之间的先后次序。
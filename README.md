## 代理模式

### 定义
>  给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。
   代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，
   代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看
   到的内容和服务或者增添客户需要的额外的新服务。

### 角色：
  1. `Subject（抽象主题角色）`：它声明了真实主题和代理主题的共同接口，这
     样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针
     对抽象主题角色进行编程。
  
  2. `Proxy（代理主题角色）`：它包含了对真实主题的引用，从而可以在任何时
     候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接
     口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实
     主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对
     象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实
     主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对
     象中的操作。
  
  3. `RealSubject（真实主题角色）`：它定义了代理角色所代表的真实对象，
     在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间
     接调用真实主题角色中定义的操作。
     
> 代理方式对比

 | 代理方式 | 实现 | 优点 | 缺点 | 特点 |
 | ---- | ----   |  ----  | ----  | ----
 | 静态代理      | 代理类与委托类实现同一接口，并且在代理类中需要硬编码接口 | 实现简单，容易理解 | 代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低 | 没有特点
 | JDK动态代理   | 代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理 | 不需要硬编码接口，代码复用率高 | 只能够代理实现了接口的委托类 | 底层使用反射机制进行方法的调用
 | CGLIB动态代理 | 代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理 | 可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口 | 不能对final类以及final方法进行代理 | 底层将方法全部存入一个数组中，通过数组索引直接进行方法调用 
   
****
  
### 优点
1. 代理模式能将代理对象与真实被调用的目标对象分离。

2. 一定程度上降低了系统的耦合度，扩展性好。

3. 保护目标对象。

4. 增强目标对象。

### 缺点
1. 代理模式会造成系统设计中类的数目增加。

2. 在客户端和目标对象增加一个代理一个代理对象，会造成请求处理速度变慢。
  
### 适用场景
1. 当客户端对象需要访问远程主机中的对象时可以使用远程代理。

2. 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，
 从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对
 象需要很长时间才能完成加载时。

3. 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供
 多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代
 理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临
 时缓冲区获取操作结果即可。

4. 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限
 时可以使用保护代理。

5. 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智
 能引用代理。

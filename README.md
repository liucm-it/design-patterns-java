## 访问者模式

### 定义
> 将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于
  这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为
  类模式中最复杂的一种模式。

### 角色
1. `抽象访问者（Visitor）角色`：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，
   该操作中的参数类型标识了被访问的具体元素。
   
2. `具体访问者（ConcreteVisitor）角色`：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。

3. `抽象元素（Element）角色`：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept()方法的参数。

4. `具体元素（ConcreteElement）角色`：实现抽象元素角色提供的 accept()操作，其方法体通常都是visitor.visit(this)，
   另外具体元素中可能还包含本身业务逻辑的相关操作。
   
5. `对象结构（ObjectStructure）角色`：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，
   通常由List、Set、Map等聚合类实现。
   
### 优点
1. 增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，
   无须修改源代码，符合“开闭原则”。

2. 将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于
   对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。

3. 让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。

### 缺点
1. 增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个
   新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”的要求。

2. 破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露
   一些自己的内部操作和内部状态，否则无法供访问者访问。
   
### 适用场景
1. 一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种
   具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作。

2. 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，
   也不希望在增加新操作时修改这些类。访问者模式使得我们可以将相关的访问操作集中起来定义在访问者类中，
   对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。

3. 对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。